



1.Projeye Katlanlar Eklenir.
  - Core
  - Entities
  - DataAccess 
  - Bussiness
  - APÝ
  - ilerde Angular ve Test

2.Core Katmanýna IEntiy Eklenir. (Entities Klasörü Altýna)
  - Bu Veritabaný sýnýflarýný Sýnýflamak için Kullanýlacak.
3.Entities katmanýna Concrete Klasörü Eklenir. Bunlar Veritabý Sýnýflarýný Tutmak için ve Ientity Interfaceni miras alýr
Bu sayade tün veritabý nesneleri gruplanýr.
Buraya Veritabýnda Kullanýlacak Sýnýflar Eklenir.

4. Data Access Katmanýna EntitiyFrameworkCore, EntitiyFrameworkCore.SqlServer ( Bu Veritabanýna göre Deðir) ,EntitiyFrameworkCore.Tools Paketleri Yüklenir
Bu Paketler ile sql Server baðlantýsý, migration gibi iþlemler yapýlýr.

5.Data Access Katmanýna Abstract ve Concrete klasörleri Açýlýr. Bunlar Soyut ve Somut Sýnýflarý ayýrmak için.
Sýnýflar ve Interfaceler Bunun içinde Bulunur

6.Core Katmanýna DataAccess Base Repositorylerini Koymak için bir Bir klasör Açýlýr ( Bu tüm Projeler ortak olduðu için Core Katmanýnda)
Bu Klasörün içinde Generic Veritabaný iþlemlerini yapan Metodlar bulunur. Bunlar her Repositorylerde ortak olduðu için Tek bir yerden yönetilir.

7.Core Katamnýnda DataAcces klasörüne IEntityRepository ve EntityRepository Sýnýflarý eklenir. Bunlar Ortak iþlenler için. T generic þeklikde.

8. DataAccess Katmanýna Baðlanmak istediðimiz Sýnýflarýn ýnterface ve Sýnýflarý Yazýlýr (IXXXRepository,XXXXRepository)
Bu Sýnýflar IEntitiyReposity , EntitiyRepository Miras alýr. Burdaki T:XXX OLUR

9.DataAccess Katmanýna  COntetxt Sýnýfý ve Býilderlar eklenir.

10. StartUp'a Çagýrmak Ýstediðimiz DbContext yazýlýr. Bu Servis içinde Connectionstring Appsetting.json'dan alýnýr.
daha sonra migration Komutu Çagrýlýr
 Add-Migration InitialCreate -project StockManagement.DataAccess
 ve Veritabanýna migration Gönderilir.
 update-database

11. Ýþ Katmanýna Gerekli Entitylerin iþ metodlarýný yapacak Soyut ve Somut Sýnýflarý Eklenir.
(ICityService,CityService)

12. Core Katmanýna Sonuçlarý Belirli Ölçekte Stabil Hale getirmek için Result klasörü Eklenir.
IResult,Result SuccessResult,ErrorResult
IDataResult ,DataResult , SuccessDataResult ,ErrorDataResult

13. Daha Sonra Bussiness Katmanýna Veritaný Sýnýfý Ýçin IResult , IData Result Dönen Metodlar Eklenir. GetAll,GetById,Add,Update,Delete..

14. Api Katmanýna ilgili Sýnýfýn Contorolleri eklenir, (Api Controller) -  Daha Sonra Gerekli Metodlar yazýlýr ve Business Katmanýndan Çagrýlýr.

15. Bussines Katmanýna Autofac paketi Yüklenir. Ve içine "DependecyResolver" klasörü açýlýr. Onun Altýna "Autofac" klasörü açýlýr.
ilerde baþka bir IoC container kullanacaðýmýz zaman ona ait klasör açabiliriz.

16. Daha Sonra Autofac klasörü altýna BussinessModule clasý eklenir ve Dependenyler eklenir.

17 Bu Eklenen Modulu program.cs de tanýtmak için gerekli kod eklenir.
.UseServiceProviderFactory(new AutofacServiceProviderFactory(builder=>builder.RegisterModule(new BusinessModule())))

18. Core Katmanýnda Entities Altýnda Concrete altýna Role,User ve UserRole tablolarý açýlýr.
Bunlar veritanýnda Kullanýcýnýn bilgileri, Role bilgileri ve kullanýnlarýn Rollerini tutar. User ve Role arasýnda Çoka Çok iliþki vardýr

19. DataAccess Katmanýnda Builders Klasörü altýnda Role,User ve UserRole için Builderler Tanýmlanýr.

20. User,Role,UserRole Ýçin Tanýmlanan Builder ve DbSetler Context alýndaki DbContext Sýnýnda Set Edilir. ve Migration Atýlýr.. Db güncellemesi Yapýlýr

21.DataAccess Katmanýnda IUserReposity ve Somutu UserRepository Tanýmlanýr. Ekstra olarak Kullanucu Rollerni Çeken bir Metod Ýmza edilir ve Metodu yazýlýr.

22.Bussiness Katmanýnda IUserService  ve Somutu UserService Eklenir. 
Eklenen Bu IUserService, UserSevice ve Repositoryler Autofac için BussinessModule Eklenir.

23.Entities Katmanýnda Dto Klasörü Eklenir ve Login,Register için Dto Sýnýflarý yazýlýr.
Bu Sýnýflar Core/Entities Altýndaki IDto implement edilir. (Dto larý gruplandýrmak için)

24. Core Katmanunda Utilities Klasörü altýna Security Klasörü eklenir. Onun altýna da Jwt  klasörü (ilerde Token kütüphanesi deðiþebilir)
jWt Altýna AccessToken ve ITokenHelper Sýnýflarý Eklenir.

25. Daha Sonra TokenOptions ve JwtHelper Eklenir. TOkenOptions token ayarlarýný Apsetiting.json dan almak için 
JwtHelper ise Token Oluþturmak için

26.JwtTokenHelper yazarken Token içine Belli kullanucu bilgileri ve Roller eklemesi gerekmektedir. Bunun için 
Core Katmanýna Extentions klasörü açýlýr ve  ClaimExtensions , Claim Listesi Extend Edilir.

27.JwtTokenHelper yazarken Belirli Enciprion iþlemeri olacagý için Core,Utilities,Security altýna Encription klasörü açýlýr ve 
SecurityKeyHelper , SigningCredentialsHelper Sýnýflarý yazýlýr. Bunlar SymmetricSecurityKey, ve SigningCredentials döner.

28.Bussiness Katmanýna IAUTHService ve Somutu AuthService eklenir. Bunlar kullanýcýnýn login ve Register iþlemleri için kullanýlýr.
Ancak kullanýcýdan gelen þifreyi hashlemk ve Dogrulamak için Core,Utilities,Security altýna Hashing klasögrü açýlýr ve HashingHelper Sýnýfý eklenir
Amacý gelen þifreleri hashlemek ve dogrulamak

29. Eklenek iki Sýnýf için BussinessModule Ekleme yapýplýr

30. Api Katmanýnda AuthController eklenir ve Login ve Register Metodlarý yazýlýr.

31. Gerekli Cors , JwtValidation için Startup.cs ek gerekli parametreler eklenir.
services.AddAuthentication  ve services.AddCors

32. Gerekli Test Yapýlarak Kullanýcý Register olup Token alýyor mu ? Login Olup Token alýyor mu kontrol edilir.

33. Veritanýndan Bir rol eklenir xxx, Eklenen Rol Kullanýcýya atanýr xxx(ýdsi) ve UserId

34. Seçilen bir metodun üstüne attribute olarak  [Authorize(Roles = "xxxx")] verilir.
Kullanýcý login olduðu tokený alýp, Postmanda Headerda seçilen Metoda istek yapar ve Eriþim var mý kontrol eder.
header => key : Authorization Pr: Breaer token

35. Bussines Katmanýna ValidationRules klasörü açýlýr ve için Kullanacaðýmýz FluentValidation klasörü açýýlýr. Ýlerde farklý Paketler kullanabiliriz.
Sonra Fluent Validation Bussiness Katmanýna yüklenir.

36.FluenTValidation klasörüne Ýlgili Sýnýf ile ilgili Kurallarý eklemek için Sýnýf açýlýr ve AbstractValidator<t> den Miras alýr.

37. Bu Sýnýf Ýçine bilirli kurallar yazýlýr ctor içinde.

38. Daha sonra Bu Kurallar ilgili Sýnýfýn add, Update metodlarýnda çagrýlabilir. Ancak Her yere ayný kodu yazmamak için sistemi Merkezi hale getiriyoruz.
Core katmanýna CrossCuttingCýncerns altýna Validation altýna ValidationHelper Sýnýfý açýlýr ve Ivalidaor ve nesne parametleri ile sistem merkezi hale getirilir.

39. Aspect ler için Core Katmanýna Utilities altýna Interceptors klasötrü açýlýr.
MethodInterceptionBaseAttribute ve MethodInterception Sýnýflarýnýn amamacý Verilen Aspectlerin Çalýþma Sýrasý, Attrubute özellikleri ..

40.Validation Aspect için Core Katmanýna Aspects klasörü altýna , Autofac altýna Validation Eklenir.
Ve ValidationAspect sýnýfý açýlýr.

41. Burada ValidationAspect Sýnýfý Ýþlemden Önce çalýþacaðý için OnBefoore Ezilerek Üstüne çalýþacak Metod Eklenir. Ve Core Katmanýna Autofac.Dynanic.Proxy paketi yüklenir.

42. Bu Aspectlerin Çagrýlmasý için BussinessModule 'e 
var assembly = System.Reflection.Assembly.GetExecutingAssembly();

            builder.RegisterAssemblyTypes(assembly).AsImplementedInterfaces()
                .EnableInterfaceInterceptors(new ProxyGenerationOptions()
                {
                    Selector = new AspectInterceptorSelector()
                }).SingleInstance();

eklenir. ve AspectInterceptorSelector Yazýlmasý gereklidir.  Core Katmanýnda Utilities altýna AspectInterceptorSelector Sýnýfý Açýlýr.

44.Daha sonra Bussines katmanýnda Validation Test Edilir.
[ValidationAspect(typeof(xxxxalidator), Priority = 1)]

45. Core Katmanýna Asprect=>Autofac altýna Transaction klasörü altna TransactionScopeAspect Sýnýfý açýlýr.
ve MethodInterception Miras Verili.  daha sonra Intercept metodu ezilerek. try catxh içinde yazýlýr. Catch içine düþerse Transaction Dispose edilir.
eger try içinde kalýrsa Complete

46. Kullanacagýmýz Cache Kütüphanesi için Core Katmanýnda CrossCuttingConcerns altýna Caching klasörü açýlýr ve ICacheService Interface Eklenir.
Bunlar Get (T Gen), Get(object) , add ..  Benzeri Metod imzalarýný tutar.

47. Ayný klasörün içine Microsoft Klasörü Açýlýr. Çünkü ilerde Cache kütüphanesi deðiþebilir. (Redis Kullanýlabilir)
Bu klasörün içine MemoryCacheService Sýnýfý Eklnir. IMemoryCache Kütüphanesi kullanarak Gerekli Metodlar doldurulur

48. Daha sonra Core Katmanýna Autofac Klasörü altýna Caching Klasörü eklenir ve Ýçine CacheAspect ve CacheRemoveAspect Sýnýflarý Eklnirç.


49. StartUp.cs de yazýlan Dependecyleri Core Katmanýna taþýmak için Utilities klasörürüne IoC klasörü açýlýrç
Ýçine ICoreModule interface i eklenir. Bu ServiceCollentionlarý Load etmek için bir metod imzasý taþýr.

50.Core Katmanýnda DependencyResolver Klasörü altýna CoreModule Sýnýfý Eklenir ve ICoreModule Ýmplement edilir.
Buradakli Load Metoduna gerekli Servicesler eklenir. Örneðin
 services.AddMemoryCache();

51.Bu Ýþlemleri kullanmak için ServiceCollection'a Extension yazýlýr ve Oýc altýna ServiceHelper Sýnýfý Eklenir. Biz servisleri çagýrmak için genelde bunu kullanacaðýz.

52.Daha Sonra Eklenen CacheAspect Test edilir.

53. Core Katmanunda Extensions altýna ClaimsPrincipalExtensions ile ClaimPrinciple extend edlilir.

54. Bussiness ve Diðer Katmanlarda User (ClaimsPrincipal) eriþmek için httpcontextAccessor CoreMudule Servis olarak eklenir.
bunu eklemek için aspnetcore.http paketi yüklenir.(Core ve Bussiness Katmanýna).

55. Daha Sonra Core Katmanýnda  Aspect Altýna Security Klasörüne SecuredOperation Sýnýfý Açýlýr.

56.SecuredOperation Role Adý ile birlikte Bussiness Metodlarýnda Çagrýlýr.
 [SecuredOperation("Cities.Get",Priority = 1)]


57.
                
